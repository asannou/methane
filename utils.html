<script>
    // 3. Utility Functions
    const Utils = {
        /**
         * Get the effective Script ID (manual input takes precedence).
         * @returns {string} The effective Script ID.
         */
        getEffectiveScriptId: () => {
            return UI.get('scriptIdSelect').value.trim();
        },

        /**
         * Save the target Script ID to Local Storage.
         * @param {string} id - The Script ID to save.
         */
        saveScriptIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('targetScriptId', id);
            }
        },

        /**
         * Save the GCP Project ID to Local Storage.
         * @param {string} id - The GCP Project ID to save.
         */
        saveGcpProjectIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('gcpProjectId', id);
            }
        },

        /**
         * Load Apps Script projects into the dropdown.
         * @param {string} [selectedId=null] - The ID of the project to pre-select.
         */
        loadProjectsIntoDropdown: (selectedId = null) => {
            const scriptIdSelect = UI.get('scriptIdSelect');
            scriptIdSelect.innerHTML = '<option value="">-- Select a Script ID --</option>';

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.status === 'success') {
                        response.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.title;
                            scriptIdSelect.appendChild(option);
                        });
                        if (selectedId) {
                            scriptIdSelect.value = selectedId;
                            // Explicitly trigger change event to update editor URL display
                            scriptIdSelect.dispatchEvent(new Event('change'));
                        }
                    }
                    else {
                        alert('Failed to load Apps Script projects: ' + response.message);
                    }
                })
                .withFailureHandler(function(error) {
                    alert('Error loading Apps Script projects: ' + error.message);
                })
                .listAppsScriptProjects();
        },

        /**
         * Update the display for the Apps Script Editor URL.
         */
        updateEditorUrlDisplay: () => {
            const scriptId = Utils.getEffectiveScriptId();
            const editorUrlDisplayDiv = UI.get('editor-url-display');
            
            UI.setHtml('editor-url-display', '');

            if (!scriptId) {
                UI.setText('editor-url-display', 'Apps Script Editor URL: (Script ID needed)');
                return;
            }

            UI.setHtml('editor-url-display', 'Apps Script Editor URL: <span class="spinner" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle; margin: 0 5px;"></span> Loading...');

            Utils.saveScriptIdToLocalStorage(scriptId);

            const editorUrl = "https://script.google.com/d/" + scriptId + "/edit";
            UI.setHtml('editor-url-display', "Apps Script Editor URL: <a href=\"" + Utils.escapeHtml(editorUrl) + "\" target=\"_blank\">" + Utils.escapeHtml(editorUrl) + "</a>");
        },

        /**
         * Validate HTML syntax.
         * @param {string} htmlString - The HTML string to validate.
         * @param {string} fileName - The name of the file being validated.
         * @returns {{isValid: boolean, message?: string}} Validation result.
         */
        validateHtml: (htmlString, fileName) => {
            console.log(`HTML validation started for file: ${fileName}`);
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const parseError = doc.querySelector('parsererror');

            if (parseError) {
                const errorMessage = parseError.textContent;
                console.error(`HTML validation failed in ${fileName}:`, errorMessage);
                return { isValid: false, message: `Syntax error found in HTML file "${fileName}": ${errorMessage}` };
            }
            console.log(`HTML validation successful for file: ${fileName}`);
            return { isValid: true };
        },

        /**
         * Generate formatted diff panels HTML using diff_match_patch library.
         * @param {string} originalSource - The original source code.
         * @param {string} proposedSource - The proposed source code.
         * @returns {{originalLineNumbersHtml: string, originalCodeContentHtml: string, proposedLineNumbersHtml: string, proposedCodeContentHtml: string}} HTML parts for diff display.
         */
        generateFormattedDiffPanels: (originalSource, proposedSource) => {
            const dmp = new diff_match_patch();
            let diffs = dmp.diff_main(originalSource, proposedSource);
            dmp.diff_cleanupSemantic(diffs);

            const originalHtmlLines = [];
            const proposedHtmlLines = [];
            const originalLineNumbers = [];
            const proposedLineNumbers = [];

            let currentOriginalLine = 1;
            let currentProposedLine = 1;

            const OMIT_THRESHOLD = 8;
            const CONTEXT_LINES = 3;

            for (let i = 0; i < diffs.length; ) {
                const type = diffs[i][0];
                const text = diffs[i][1];
                const lines = text.split('\n');

                if (type === DIFF_EQUAL) {
                    let equalBlockLines = [];
                    let j = i;
                    while (j < diffs.length && diffs[j][0] === DIFF_EQUAL) {
                        equalBlockLines = equalBlockLines.concat(diffs[j][1].split('\n'));
                        j++;
                    }

                    // Remove the last empty string if it results from trailing newline, unless it's a standalone empty line
                    if (equalBlockLines.length > 0 && equalBlockLines[equalBlockLines.length - 1] === '' && equalBlockLines.length > 1) {
                        equalBlockLines.pop();
                    }

                    if (equalBlockLines.length > OMIT_THRESHOLD) {
                        // Add leading context
                        for (let k = 0; k < CONTEXT_LINES; k++) {
                            const line = equalBlockLines[k];
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                        }

                        // Add omitted block placeholder
                        const omittedCount = equalBlockLines.length - (2 * CONTEXT_LINES);
                        const originalOmittedStart = currentOriginalLine;
                        const proposedOmittedStart = currentProposedLine;

                        currentOriginalLine += omittedCount;
                        currentProposedLine += omittedCount;

                        originalLineNumbers.push(`<div class="diff-line-omitted">${originalOmittedStart}-${currentOriginalLine - 1}</div>`);
                        originalHtmlLines.push(`<div class="diff-line-omitted">... ${omittedCount} lines omitted ...</div>`);
                        proposedLineNumbers.push(`<div class="diff-line-omitted">${proposedOmittedStart}-${currentProposedLine - 1}</div>`);
                        proposedHtmlLines.push(`<div class="diff-line-omitted">... ${omittedCount} lines omitted ...</div>`);

                        // Add trailing context
                        for (let k = equalBlockLines.length - CONTEXT_LINES; k < equalBlockLines.length; k++) {
                            const line = equalBlockLines[k];
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                        }
                    } else {
                        // Add all equal lines
                        for (const line of equalBlockLines) {
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                        }
                    }
                    i = j; // Move index past the processed equal block
                } else {
                    // Handle added or removed lines
                    const actualLines = text.split('\n');
                    // Remove the last empty string if it results from trailing newline, unless it's a standalone empty line
                    if (actualLines.length > 0 && actualLines[actualLines.length - 1] === '' && actualLines.length > 1) {
                        actualLines.pop();
                    }
                    
                    for (const line of actualLines) {
                        if (type === DIFF_INSERT) {
                            originalLineNumbers.push(`<div>&nbsp;</div>`);
                            originalHtmlLines.push(`<div class="diff-line-empty-fill">&nbsp;</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-added">${Utils.escapeHtml(line)}</div>`);
                        } else if (type === DIFF_DELETE) {
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-removed">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>&nbsp;</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-empty-fill">&nbsp;</div>`);
                        }
                    }
                    i++;
                }
            }

            return {
                originalLineNumbersHtml: originalLineNumbers.join(''),
                originalCodeContentHtml: originalHtmlLines.join(''),
                proposedLineNumbersHtml: proposedLineNumbers.join(''),
                proposedCodeContentHtml: proposedHtmlLines.join('')
            };
        },

        /**
         * Helper to generate simple line numbers HTML for deleted files.
         * @param {string} source - The source code.
         * @returns {string} HTML for line numbers.
         */
        generateLineNumbersHtml: (source) => {
            const lines = source ? source.split('\n') : [];
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div>${i + 1}</div>`;
            }
            return html;
        },

        /**
         * Helper to generate simple source HTML for deleted files.
         * @param {string} source - The source code.
         * @returns {string} HTML for source content.
         */
        generateSourceHtml: (source) => {
            const lines = source ? source.split('\n') : [];
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div class="diff-line-equal">${Utils.escapeHtml(lines[i])}</div>`;
            }
            return html;
        },

        /**
         * Get file extension based on file type.
         * @param {string} type - The file type (SERVER_JS, JSON, HTML).
         * @returns {string} The corresponding file extension.
         */
        getFileExtension: (type) => {
            switch (type) {
                case 'SERVER_JS': return 'gs';
                case 'JSON': return 'json';
                default: return 'html';
            }
        },

        /**
         * Escape HTML entities in a string.
         * @param {string} text - The text to escape.
         * @returns {string} The escaped HTML string.
         */
        escapeHtml: (text) => {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }
    };
</script>
