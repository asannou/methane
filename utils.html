<script>
    // 3. Utility Functions
    const Utils = {
        /**
         * Get the effective Script ID (manual input takes precedence).
         * @returns {string} The effective Script ID.
         */
        getEffectiveScriptId: () => {
            return UI.get('scriptIdSelect').value.trim();
        },

        /**
         * Save the target Script ID to Local Storage.
         * @param {string} id - The Script ID to save.
         */
        saveScriptIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('targetScriptId', id);
            }
        },

        /**
         * Save the GCP Project ID to Local Storage.
         * @param {string} id - The GCP Project ID to save.
         */
        saveGcpProjectIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('gcpProjectId', id);
            }
        },

        /**
         * Load Apps Script projects into the dropdown.
         * @param {string} [selectedId=null] - The ID of the project to pre-select.
         */
        loadProjectsIntoDropdown: (selectedId = null) => {
            const scriptIdSelect = UI.get('scriptIdSelect');
            scriptIdSelect.innerHTML = '<option value="">-- Select a Script ID --</option>';

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.status === 'success') {
                        response.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.title;
                            scriptIdSelect.appendChild(option);
                        });
                        if (selectedId) {
                            scriptIdSelect.value = selectedId;
                            // Explicitly trigger change event to update editor URL display
                            scriptIdSelect.dispatchEvent(new Event('change'));
                        }
                    }
                    else {
                        alert('Failed to load Apps Script projects: ' + response.message);
                    }
                })
                .withFailureHandler(function(error) {
                    alert('Error loading Apps Script projects: ' + error.message);
                })
                .listAppsScriptProjects();
        },

        /**
         * Update the display for the Apps Script Editor URL.
         */
        updateEditorUrlDisplay: () => {
            const scriptId = Utils.getEffectiveScriptId();
            const editorUrlDisplayDiv = UI.get('editor-url-display');
            
            UI.setHtml('editor-url-display', '');

            if (!scriptId) {
                UI.setText('editor-url-display', 'Apps Script Editor URL: (Script ID needed)');
                return;
            }

            UI.setHtml('editor-url-display', 'Apps Script Editor URL: <span class="spinner" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle; margin: 0 5px;"></span> Loading...');

            Utils.saveScriptIdToLocalStorage(scriptId);

            const editorUrl = "https://script.google.com/d/" + scriptId + "/edit";
            UI.setHtml('editor-url-display', "Apps Script Editor URL: <a href=\"" + Utils.escapeHtml(editorUrl) + "\" target=\"_blank\">" + Utils.escapeHtml(editorUrl) + "</a>");
        },

        /**
         * Validate HTML syntax.
         * @param {string} htmlString - The HTML string to validate.
         * @param {string} fileName - The name of the file being validated.
         * @returns {{isValid: boolean, message?: string}} Validation result.
         */
        validateHtml: (htmlString, fileName) => {
            console.log(`HTML validation started for file: ${fileName}`);
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const parseError = doc.querySelector('parsererror');

            if (parseError) {
                const errorMessage = parseError.textContent;
                console.error(`HTML validation failed in ${fileName}:`, errorMessage);
                return { isValid: false, message: `Syntax error found in HTML file "${fileName}": ${errorMessage}` };
            }
            console.log(`HTML validation successful for file: ${fileName}`);
            return { isValid: true };
        },

        /**
         * Displays the file comparison and proposed changes in the UI.
         * @param {Array<object>} originalFiles - Array of original file objects.
         * @param {Array<object>} proposedFiles - Array of proposed file objects (with new source or replace operations).
         * @param {Array<string>} deletedFileNames - Array of file names marked for deletion.
         * @returns {boolean} True if any changes were displayed, false otherwise.
         */
        displayFileComparison: (originalFiles, proposedFiles, deletedFileNames) => {
            const proposedFilesDisplay = UI.get('proposed-files-display');
            proposedFilesDisplay.innerHTML = ''; // Clear previous content

            let hasChanges = false;

            // Create maps for easier lookup
            const originalFilesMap = new Map(originalFiles.map(f => [f.name, f]));
            const proposedFilesMap = new Map(proposedFiles.map(f => [f.name, f]));

            // 1. Display DELETED files
            deletedFileNames.forEach(deletedFileName => {
                const originalFile = originalFilesMap.get(deletedFileName);
                if (originalFile) { // Ensure the file actually existed in original project
                    hasChanges = true;
                    const ext = Utils.getFileExtension(originalFile.type);
                    const deletedHtml = `
                        <div class="file-comparison is-deleted">
                            <h4 class="title is-5">DELETED: <span class="file-name-deleted">${Utils.escapeHtml(deletedFileName)}.${ext}</span></h4>
                            <div class="deleted-message notification is-danger is-light">This file is proposed for deletion. Original content shown below (struck-through):</div>
                            <pre><div class="line-numbers-col">${Utils.generateLineNumbersHtml(originalFile.source)}</div><div class="code-content-col diff-line-removed">${Utils.generateSourceHtml(originalFile.source)}</div></pre>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += deletedHtml;
                } else {
                    console.warn(`File '${deletedFileName}' was marked for deletion but not found in original files. Skipping deletion display.`);
                }
            });

            // 2. Display NEW, MODIFIED, or REPLACE files
            proposedFiles.forEach(proposedFile => {
                const originalFile = originalFilesMap.get(proposedFile.name);
                let fileContentHtml = '';

                if (proposedFile.type === 'REPLACE') {
                    // This is a REPLACE operation
                    hasChanges = true;
                    const originalSourceForReplace = originalFile ? originalFile.source : 'File content not available for comparison.';
                    const originalFileTypeForReplace = originalFile ? Utils.getFileExtension(originalFile.type) : 'unknown';

                    fileContentHtml = `
                        <div class="file-comparison is-replace">
                            <h4 class="title is-5">REPLACE Operation: ${Utils.escapeHtml(proposedFile.name)}.${originalFileTypeForReplace}</h4>
                            <p class="content">This operation will replace specific text within the file. ${proposedFile.isGlobalReplace ? 'All occurrences will be replaced (global).' : 'Only the first occurrence will be replaced.'}</p>
                            <div class="columns">
                                <div class="column">
                                    <h5 class="title is-6 has-text-danger">Old String:</h5>
                                    <pre class="replacement-view replacement-old">${Utils.escapeHtml(proposedFile.old_string)}</pre>
                                </div>
                                <div class="column">
                                    <h5 class="title is-6 has-text-success">New String:</h5>
                                    <pre class="replacement-view replacement-new">${Utils.escapeHtml(proposedFile.new_string)}</pre>
                                </div>
                            </div>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += fileContentHtml;

                } else if (!originalFile) {
                    // This is a NEW file (exists in proposed but not in original)
                    hasChanges = true;
                    const ext = Utils.getFileExtension(proposedFile.type);
                    fileContentHtml = `
                        <div class="file-comparison">
                            <h4 class="title is-5">NEW FILE: ${Utils.escapeHtml(proposedFile.name)}.${ext}</h4>
                            <div class="notification is-info is-light">This is a new file proposed by the AI.</div>
                            <pre><div class="line-numbers-col">${Utils.generateLineNumbersHtml(proposedFile.source)}</div><div class="code-content-col diff-line-added">${Utils.generateSourceHtml(proposedFile.source)}</div></pre>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += fileContentHtml;

                } else if (originalFile.source !== proposedFile.source) {
                    // This is a MODIFIED file (exists in both, but source is different)
                    hasChanges = true;
                    const diffsHtml = Utils.generateFormattedDiffPanels(originalFile.source, proposedFile.source);
                    const ext = Utils.getFileExtension(proposedFile.type);
                    fileContentHtml = `
                        <div class="file-comparison">
                            <div class="original-file-panel">
                                <h4 class="title is-5">Original: ${Utils.escapeHtml(originalFile.name)}.${ext}</h4>
                                <pre><div class="line-numbers-col">${diffsHtml.originalLineNumbersHtml}</div><div class="code-content-col">${diffsHtml.originalCodeContentHtml}</div></pre>
                            </div>
                            <div class="proposed-file-panel">
                                <h4 class="title is-5">Proposed: ${Utils.escapeHtml(proposedFile.name)}.${ext}</h4>
                                <pre><div class="line-numbers-col">${diffsHtml.proposedLineNumbersHtml}</div><div class="code-content-col">${diffsHtml.proposedCodeContentHtml}</div></pre>
                            </div>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += fileContentHtml;
                }
                // Files present in both original and proposed, but with identical content, are skipped (no display needed)
            });

            // If no changes at all (neither deleted, new, modified, nor replace operations)
            if (!hasChanges) {
                proposedFilesDisplay.innerHTML = `<p class="notification is-info is-light">No changes proposed by AI for the selected script. This could mean the prompt was fully satisfied without code modifications, or no relevant changes were found.</p>`;
            }

            return hasChanges;
        },

        /**
         * Generate formatted diff panels HTML using diff_match_patch library.
         * @param {string} originalSource - The original source code.
         * @param {string} proposedSource - The proposed source code.
         * @returns {{originalLineNumbersHtml: string, originalCodeContentHtml: string, proposedLineNumbersHtml: string, proposedCodeContentHtml: string}} HTML parts for diff display.
         */
        generateFormattedDiffPanels: (originalSource, proposedSource) => {
            const dmp = new diff_match_patch();
            let diffs = dmp.diff_main(originalSource, proposedSource);
            dmp.diff_cleanupSemantic(diffs);

            const originalHtmlLines = [];
            const proposedHtmlLines = [];
            const originalLineNumbers = [];
            const proposedLineNumbers = [];

            let currentOriginalLine = 1;
            let currentProposedLine = 1;

            const OMIT_THRESHOLD = 8;
            const CONTEXT_LINES = 3;

            for (let i = 0; i < diffs.length; ) {
                const type = diffs[i][0];
                const text = diffs[i][1];

                if (type === DIFF_EQUAL) {
                    let combinedEqualLines = [];
                    let j = i;
                    while (j < diffs.length && diffs[j][0] === DIFF_EQUAL) {
                        // Correctly split each equal segment into logical lines before concatenation
                        const currentSegmentLines = Utils.getActualContentLines(diffs[j][1]);
                        combinedEqualLines = combinedEqualLines.concat(currentSegmentLines);
                        j++;
                    }

                    if (combinedEqualLines.length > OMIT_THRESHOLD) {
                        // Add leading context
                        for (let k = 0; k < CONTEXT_LINES; k++) {
                            const line = combinedEqualLines[k];
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                        }

                        // Add omitted block placeholder
                        const omittedCount = combinedEqualLines.length - (2 * CONTEXT_LINES);
                        const originalOmittedStart = currentOriginalLine;
                        const proposedOmittedStart = currentProposedLine;

                        currentOriginalLine += omittedCount;
                        currentProposedLine += omittedCount;

                        originalLineNumbers.push(`<div class="diff-line-omitted">${originalOmittedStart}-${currentOriginalLine - 1}</div>`);
                        originalHtmlLines.push(`<div class="diff-line-omitted">... ${omittedCount} lines omitted ...</div>`);
                        proposedLineNumbers.push(`<div class="diff-line-omitted">${proposedOmittedStart}-${currentProposedLine - 1}</div>`);
                        proposedHtmlLines.push(`<div class="diff-line-omitted">... ${omittedCount} lines omitted ...</div>`);

                        // Add trailing context
                        for (let k = combinedEqualLines.length - CONTEXT_LINES; k < combinedEqualLines.length; k++) {
                            const line = combinedEqualLines[k];
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                        }
                    } else {
                        // Add all equal lines
                        for (const line of combinedEqualLines) {
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`);
                        }
                    }
                    i = j; // Move index past the processed equal block
                } else {
                    // Handle added or removed lines
                    // Use getActualContentLines for consistent line interpretation
                    const actualLines = Utils.getActualContentLines(text);
                    
                    for (const line of actualLines) {
                        if (type === DIFF_INSERT) {
                            originalLineNumbers.push(`<div>&nbsp;</div>`);
                            originalHtmlLines.push(`<div class="diff-line-empty-fill">&nbsp;</div>`);
                            proposedLineNumbers.push(`<div>${currentProposedLine++}</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-added">${Utils.escapeHtml(line)}</div>`);
                        } else if (type === DIFF_DELETE) {
                            originalLineNumbers.push(`<div>${currentOriginalLine++}</div>`);
                            originalHtmlLines.push(`<div class="diff-line-removed">${Utils.escapeHtml(line)}</div>`);
                            proposedLineNumbers.push(`<div>&nbsp;</div>`);
                            proposedHtmlLines.push(`<div class="diff-line-empty-fill">&nbsp;</div>`);
                        }
                    }
                    i++;
                }
            }

            return {
                originalLineNumbersHtml: originalLineNumbers.join(''),
                originalCodeContentHtml: originalHtmlLines.join(''),
                proposedLineNumbersHtml: proposedLineNumbers.join(''),
                proposedCodeContentHtml: proposedHtmlLines.join('')
            };
        },

        /**
         * Splits a string into an array of lines, correctly handling trailing newlines.
         * A trailing newline character means the last line is empty, but it's not an *additional* line.
         * For example, "a\n" represents one line "a". "a\n\n" represents two lines "a" and "".
         * @param {string} text - The input string.
         * @returns {Array<string>} An array of logical lines.
         */
        getActualContentLines: (text) => {
            if (text === null || text === undefined) {
                return [];
            }
            const lines = text.split('\n');
            // If the original string ends with a newline, the last element from split is an empty string.
            // This empty string represents the content *after* the final newline, which is typically not a new logical line for display.
            // We only pop if the last character *of the original text* was a newline AND the last element of the split array is an empty string.
            if (text.length > 0 && text.charAt(text.length - 1) === '\n') {
                if (lines.length > 0 && lines[lines.length - 1] === '') {
                    lines.pop();
                }
            }
            return lines;
        },

        /**
         * Helper to generate simple line numbers HTML for deleted/new files.
         * @param {string} source - The source code.
         * @returns {string} HTML for line numbers.
         */
        generateLineNumbersHtml: (source) => {
            const lines = Utils.getActualContentLines(source); // Use the new helper
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div>${i + 1}</div>`;
            }
            return html;
        },

        /**
         * Helper to generate simple source HTML for deleted/new files.
         * @param {string} source - The source code.
         * @returns {string} HTML for source content.
         */
        generateSourceHtml: (source) => {
            const lines = Utils.getActualContentLines(source); // Use the new helper
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div class="diff-line-equal">${Utils.escapeHtml(lines[i])}</div>`;
            }
            return html;
        },

        /**
         * Get file extension based on file type.
         * @param {string} type - The file type (SERVER_JS, JSON, HTML).
         * @returns {string} The corresponding file extension.
         */
        getFileExtension: (type) => {
            switch (type) {
                case 'SERVER_JS': return 'gs';
                case 'JSON': return 'json';
                default: return 'html';
            }
        },

        /**
         * Escape HTML entities in a string.
         * @param {string} text - The text to escape.
         * @returns {string} The escaped HTML string.
         */
        escapeHtml: (text) => {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }
    };
</script>