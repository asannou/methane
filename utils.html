<script>
    // 3. Utility Functions
    const Utils = {
        /**
         * Get the effective Script ID (manual input takes precedence).
         * @returns {string} The effective Script ID.
         */
        getEffectiveScriptId: () => {
            const manualId = UI.get('scriptIdManualInput').value.trim();
            if (manualId) {
                return manualId;
            }
            return UI.get('scriptIdSelect').value.trim();
        },

        /**
         * Save the target Script ID to Local Storage.
         * @param {string} id - The Script ID to save.
         */
        saveScriptIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('targetScriptId', id);
            }
        },

        /**
         * Save the GCP Project ID to Local Storage.
         * @param {string} id - The GCP Project ID to save.
         */
        saveGcpProjectIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('gcpProjectId', id);
            }
        },

        /**
         * Load Apps Script projects into the dropdown.
         * @param {string} [selectedId=null] - The ID of the project to pre-select.
         */
        loadProjectsIntoDropdown: (selectedId = null) => {
            const scriptIdSelect = UI.get('scriptIdSelect');
            scriptIdSelect.innerHTML = '<option value="">-- Select or type manually --</option>';

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.status === 'success') {
                        response.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.title;
                            scriptIdSelect.appendChild(option);
                        });
                        if (selectedId) {
                            scriptIdSelect.value = selectedId;
                        }
                    } else {
                        alert('Failed to load Apps Script projects: ' + response.message);
                    }
                })
                .withFailureHandler(function(error) {
                    alert('Error loading Apps Script projects: ' + error.message);
                })
                .listAppsScriptProjects();
        },

        /**
         * Update the display for the Apps Script Editor URL.
         */
        updateEditorUrlDisplay: () => {
            const scriptId = Utils.getEffectiveScriptId();
            const editorUrlDisplayDiv = UI.get('editor-url-display');
            
            UI.setHtml('editor-url-display', '');

            if (!scriptId) {
                UI.setText('editor-url-display', 'Apps Script Editor URL: (Script ID needed)');
                return;
            }

            UI.setHtml('editor-url-display', 'Apps Script Editor URL: <span class="spinner" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle; margin: 0 5px;"></span> Loading...');

            Utils.saveScriptIdToLocalStorage(scriptId);

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.startsWith("Error:")) {
                        UI.setText('editor-url-display', `Apps Script Editor URL: ${response}`);
                    } else {
                        UI.setHtml('editor-url-display', `Apps Script Editor URL: <a href="${response}" target="_blank">${response}</a>`);
                    }
                })
                .withFailureHandler(function(error) {
                    UI.setText('editor-url-display', `Apps Script Editor URL: Error - ${error.message}`);
                })
                .getScriptEditorUrl(scriptId);
        },

        /**
         * Validate HTML syntax.
         * @param {string} htmlString - The HTML string to validate.
         * @param {string} fileName - The name of the file being validated.
         * @returns {{isValid: boolean, message?: string}} Validation result.
         */
        validateHtml: (htmlString, fileName) => {
            console.log(`HTML validation started for file: ${fileName}`);
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const parseError = doc.querySelector('parsererror');

            if (parseError) {
                const errorMessage = parseError.textContent;
                console.error(`HTML validation failed in ${fileName}:`, errorMessage);
                return { isValid: false, message: `Syntax error found in HTML file "${fileName}": ${errorMessage}` };
            }
            console.log(`HTML validation successful for file: ${fileName}`);
            return { isValid: true };
        },

        /**
         * Generate formatted diff panels HTML using diff-match-patch library.
         * @param {string} originalSource - The original source code.
         * @param {string} proposedSource - The proposed source code.
         * @returns {{originalLineNumbersHtml: string, originalCodeContentHtml: string, proposedLineNumbersHtml: string, proposedCodeContentHtml: string}} HTML parts for diff display.
         */
        generateFormattedDiffPanels: (originalSource, proposedSource) => {
            // Ensure diff_match_patch is loaded
            if (typeof diff_match_patch === 'undefined') {
                console.error("diff_match_patch library is not loaded. Cannot generate diffs.");
                // Fallback to simple side-by-side display if the library is not available
                const originalLines = originalSource ? originalSource.split('\n') : [];
                const proposedLines = proposedSource ? proposedSource.split('\n') : [];
                let originalLineNumbersHtml = '';
                let originalCodeContentHtml = '';
                let proposedLineNumbersHtml = '';
                let proposedCodeContentHtml = '';

                originalLines.forEach((line, i) => {
                    originalLineNumbersHtml += `<div>${i + 1}</div>`;
                    originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`;
                });
                proposedLines.forEach((line, i) => {
                    proposedLineNumbersHtml += `<div>${i + 1}</div>`;
                    proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(line)}</div>`;
                });
                return { originalLineNumbersHtml, originalCodeContentHtml, proposedLineNumbersHtml, proposedCodeContentHtml };
            }

            const dmp = new diff_match_patch();
            dmp.Diff_Timeout = 1.0; // Timeout in seconds to prevent very long diff computations

            // Perform line-based diff using dmp's helper functions
            const a = dmp.diff_linesToChars_(originalSource, proposedSource);
            const lineText1 = a[0];
            const lineText2 = a[1];
            const lineArray = a[2];

            const diffs = dmp.diff_main(lineText1, lineText2, false); // false for checklines
            dmp.diff_charsToLines_(diffs, lineArray);

            // Process diffs to handle 'modified' lines (removed + added at same logical position)
            // and split multi-line diff entries into single-line entries for easier processing.
            const processedDiffs = [];
            for (let i = 0; i < diffs.length; i++) {
                const type = diffs[i][0];
                const text = diffs[i][1];
                const lines = text.split('\n');

                // Check for removed + added pair to form a 'modified' line
                if (type === diff_match_patch.DIFF_DELETE && i + 1 < diffs.length && diffs[i+1][0] === diff_match_patch.DIFF_INSERT) {
                    const nextText = diffs[i+1][1];
                    const nextLines = nextText.split('\n');
                    
                    // If both are single lines, consider them a modification
                    if (lines.length === 1 && nextLines.length === 1) {
                        processedDiffs.push({ type: 'modified', original: lines[0], proposed: nextLines[0] });
                        i++; // Skip the next element as it's been processed
                        continue;
                    }
                    // If multi-line or not a single-line pair, fall through to default handling below
                }

                // Default handling for equal, single remove, single add, or multi-line remove/add
                lines.forEach((line, index) => {
                    // Avoid adding an empty string line if it's the very last line and was just a trailing newline character
                    // The `split('\n')` method will add an empty string at the end if the string ends with a newline.
                    if (line === '' && index === lines.length - 1 && text.endsWith('\n')) {
                        return;
                    }
                    if (type === diff_match_patch.DIFF_EQUAL) {
                        processedDiffs.push({ type: 'equal', original: line, proposed: line });
                    } else if (type === diff_match_patch.DIFF_DELETE) {
                        processedDiffs.push({ type: 'removed', original: line, proposed: '' });
                    } else if (type === diff_match_patch.DIFF_INSERT) {
                        processedDiffs.push({ type: 'added', original: '', proposed: line });
                    }
                });
            }

            // Now apply the omission logic to processedDiffs (adapted from original logic)
            const OMIT_THRESHOLD = 8;
            const CONTEXT_LINES = 3;

            let originalLineNumbersHtml = '';
            let originalCodeContentHtml = '';
            let proposedLineNumbersHtml = '';
            let proposedCodeContentHtml = '';

            let currentOriginalLineNum = 1;
            let currentProposedLineNum = 1;

            let k = 0;
            while (k < processedDiffs.length) {
                const entry = processedDiffs[k];

                if (entry.type === 'equal') {
                    let equalBlockStartIndex = k;
                    let equalCount = 0;

                    while (k < processedDiffs.length && processedDiffs[k].type === 'equal') {
                        equalCount++;
                        k++;
                    }

                    if (equalCount > OMIT_THRESHOLD) {
                        // Add leading context lines
                        for (let l = 0; l < CONTEXT_LINES && (equalBlockStartIndex + l) < processedDiffs.length; l++) {
                            const lineEntry = processedDiffs[equalBlockStartIndex + l];
                            originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                            originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.original)}</div>`;
                            proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                            proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.proposed)}</div>`;
                            currentOriginalLineNum++;
                            currentProposedLineNum++;
                        }

                        const omittedLinesCount = equalCount - (2 * CONTEXT_LINES);
                        const originalOmittedStart = currentOriginalLineNum;
                        const proposedOmittedStart = currentProposedLineNum;

                        currentOriginalLineNum += omittedLinesCount;
                        currentProposedLineNum += omittedLinesCount;

                        originalLineNumbersHtml += `<div class="diff-line-omitted">${originalOmittedStart}-${currentOriginalLineNum - 1}</div>`;
                        originalCodeContentHtml += `<div class="diff-line-omitted">... ${omittedLinesCount} lines omitted ...</div>`;
                        proposedLineNumbersHtml += `<div class="diff-line-omitted">${proposedOmittedStart}-${currentProposedLineNum - 1}</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-omitted">... ${omittedLinesCount} lines omitted ...</div>`;

                        // Add trailing context lines
                        for (let l = 0; l < CONTEXT_LINES && (equalBlockStartIndex + equalCount - CONTEXT_LINES + l) < processedDiffs.length; l++) {
                            const lineEntry = processedDiffs[equalBlockStartIndex + equalCount - CONTEXT_LINES + l];
                            originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                            originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.original)}</div>`;
                            proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                            proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.proposed)}</div>`;
                            currentOriginalLineNum++;
                            currentProposedLineNum++;
                        }

                    } else {
                        for (let l = 0; l < equalCount; l++) {
                            const lineEntry = processedDiffs[equalBlockStartIndex + l];
                            originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                            originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.original)}</div>`;
                            proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                            proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.proposed)}</div>`;
                            currentOriginalLineNum++;
                            currentProposedLineNum++;
                        }
                    }
                } else {
                    if (entry.type === 'added') {
                        originalLineNumbersHtml += `<div>&nbsp;</div>`;
                        originalCodeContentHtml += `<div class="diff-line-empty-fill">&nbsp;</div>`;
                        proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-added">${Utils.escapeHtml(entry.proposed)}</div>`;
                        currentProposedLineNum++;
                    } else if (entry.type === 'removed') {
                        originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                        originalCodeContentHtml += `<div class="diff-line-removed">${Utils.escapeHtml(entry.original)}</div>`;
                        proposedLineNumbersHtml += `<div>&nbsp;</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-empty-fill">&nbsp;</div>`;
                        currentOriginalLineNum++;
                    } else if (entry.type === 'modified') {
                        originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                        originalCodeContentHtml += `<div class="diff-line-modified">${Utils.escapeHtml(entry.original)}</div>`;
                        proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-modified">${Utils.escapeHtml(entry.proposed)}</div>`;
                        currentOriginalLineNum++;
                        currentProposedLineNum++;
                    }
                    k++;
                }
            }

            return {
                originalLineNumbersHtml, originalCodeContentHtml,
                proposedLineNumbersHtml, proposedCodeContentHtml
            };
        },

        /**
         * Display file comparisons in the UI.
         * @param {Array<object>} originalFiles - The original files array.
         * @param {Array<object>} proposedFiles - The proposed files array.
         * @param {Array<string>} [deletedFileNames=[]] - Array of file names explicitly marked for deletion by AI.
         */
        displayFileComparison: (originalFiles, proposedFiles, deletedFileNames = []) => {
            const displayArea = UI.get('proposedFilesDisplay');
            UI.setHtml('proposedFilesDisplay', '');

            // Convert proposedFiles and originalFiles to Maps for easy lookup by name
            const proposedFilesMap = new Map(proposedFiles.map(f => [f.name, f]));
            const originalFilesMap = new Map(originalFiles.map(f => [f.name, f]));

            // 1. Identify and display DELETED files explicitly from `deletedFileNames`
            const explicitDeletedFiles = [];
            if (deletedFileNames && Array.isArray(deletedFileNames)) {
                deletedFileNames.forEach(deletedName => {
                    const fileToDelete = originalFilesMap.get(deletedName);
                    if (fileToDelete) {
                        explicitDeletedFiles.push(fileToDelete);
                    } else {
                        console.warn(`File '${deletedName}' was marked for deletion but not found in original project content. It might already be gone or name is incorrect.`);
                    }
                });
            }

            // If there are no proposed changes (neither additions/updates nor explicit deletions).
            // Check if proposedFiles is empty AND explicitDeletedFiles is empty.
            if (explicitDeletedFiles.length === 0 && proposedFiles.length === 0) {
                UI.setHtml('proposedFilesDisplay', '<p>AI did not propose any changes (no files added, updated, or deleted).</p>');
                return;
            }

            explicitDeletedFiles.forEach(deletedFile => {
                const name = deletedFile.name;
                const fileType = deletedFile.type;
                const originalSource = deletedFile.source;

                const fileComparisonDiv = document.createElement('div');
                fileComparisonDiv.className = 'file-comparison is-deleted'; // Always add is-deleted class

                fileComparisonDiv.innerHTML = `
                    <div>
                        <h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Original)</h4>
                        <pre class="scroll-sync-target">
                            <div class="line-numbers-col">
                                ${Utils.generateLineNumbersHtml(originalSource)}
                            </div>
                            <div class="code-content-col">
                                ${Utils.generateSourceHtml(originalSource)}
                            </div>
                        </pre>
                    </div>
                    <div>
                        <h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Proposed) <span class="file-name-deleted">(DELETED)</span></h4>
                        <div class="deleted-message">
                            <p>このファイルは削除されます。</p>
                            <p>元のコンテンツは参照用に左側に表示されています。</p>
                        </div>
                    </div>
                `;
                displayArea.appendChild(fileComparisonDiv);
                // No scroll sync for deleted files as right panel is text.
            });

            // 2. Identify and display UPDATED/NEW files
            proposedFiles.forEach(proposedFile => {
                // Ensure this file wasn't also in the explicit deleted list.
                // If AI follows instructions, files in `proposedFiles` should NOT be in `deletedFileNames`.
                if (explicitDeletedFiles.some(f => f.name === proposedFile.name)) {
                    console.warn(`File '${proposedFile.name}' was proposed for update/addition AND for deletion. This should not happen. Skipping update/new file display as it's already handled as deleted.`);
                    return;
                }

                const name = proposedFile.name;
                const fileType = proposedFile.type;
                
                const originalFile = originalFilesMap.get(name);
                const originalSource = originalFile ? originalFile.source : ''; // Will be empty string if it's a new file

                const fileComparisonDiv = document.createElement('div');
                fileComparisonDiv.className = 'file-comparison';

                const diffHtmlData = Utils.generateFormattedDiffPanels(originalSource, proposedFile.source);

                const statusLabel = originalFile ? '(Updated)' : '(New File)'; // Determine status for display purposes

                const originalContentDiv = document.createElement('div');
                originalContentDiv.innerHTML = `<h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Original)</h4><pre class="scroll-sync-target">
                    <div class="line-numbers-col">${diffHtmlData.originalLineNumbersHtml}</div>
                    <div class="code-content-col">${diffHtmlData.originalCodeContentHtml}</div>
                </pre>`;
                
                const proposedContentDiv = document.createElement('div');
                proposedContentDiv.innerHTML = `<h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Proposed) <span class="has-text-info is-size-7">${statusLabel}</span></h4><pre class="scroll-sync-target">
                    <div class="line-numbers-col">${diffHtmlData.proposedLineNumbersHtml}</div>
                    <div class="code-content-col">${diffHtmlData.proposedCodeContentHtml}</div>
                </pre>`;
                
                fileComparisonDiv.appendChild(originalContentDiv);
                fileComparisonDiv.appendChild(proposedContentDiv);
                
                displayArea.appendChild(fileComparisonDiv);

                // Apply scroll sync
                const preElements = fileComparisonDiv.querySelectorAll('.scroll-sync-target');
                if (preElements.length === 2) {
                    const pre1 = preElements[0];
                    const pre2 = preElements[1];

                    let isSyncing = false;

                    pre1.addEventListener('scroll', function() {
                        if (!isSyncing) {
                            isSyncing = true;
                            pre2.scrollTop = pre1.scrollTop;
                            isSyncing = false;
                        }
                    });

                    pre2.addEventListener('scroll', function() {
                        if (!isSyncing) {
                            isSyncing = true;
                            pre1.scrollTop = pre2.scrollTop;
                            isSyncing = false;
                        }
                    });
                }
            });
        },

        /**
         * Helper to generate simple line numbers HTML for deleted files.
         * @param {string} source - The source code.
         * @returns {string} HTML for line numbers.
         */
        generateLineNumbersHtml: (source) => {
            const lines = source ? source.split('\n') : [];
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div>${i + 1}</div>`;
            }
            return html;
        },

        /**
         * Helper to generate simple source HTML for deleted files.
         * @param {string} source - The source code.
         * @returns {string} HTML for source content.
         */
        generateSourceHtml: (source) => {
            const lines = source ? source.split('\n') : [];
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div class="diff-line-equal">${Utils.escapeHtml(lines[i])}</div>`;
            }
            return html;
        },

        /**
         * Get file extension based on file type.
         * @param {string} type - The file type (SERVER_JS, JSON, HTML).
         * @returns {string} The corresponding file extension.
         */
        getFileExtension: (type) => {
            switch (type) {
                case 'SERVER_JS': return 'gs';
                case 'JSON': return 'json';
                default: return 'html';
            }
        },

        /**
         * Escape HTML entities in a string.
         * @param {string} text - The text to escape.
         * @returns {string} The escaped HTML string.
         */
        escapeHtml: (text) => {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }
    };
</script>
