<script>
    // 3. Utility Functions
    const Utils = {
        /**
         * Get the effective Script ID (manual input takes precedence).
         * @returns {string} The effective Script ID.
         */
        getEffectiveScriptId: () => {
            return UI.get('scriptIdSelect').value.trim();
        },

        /**
         * Save the target Script ID to Local Storage.
         * @param {string} id - The Script ID to save.
         */
        saveScriptIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('targetScriptId', id);
            }
        },

        /**
         * Save the GCP Project ID to Local Storage.
         * @param {string} id - The GCP Project ID to save.
         */
        saveGcpProjectIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('gcpProjectId', id);
            }
        },

        /**
         * Load Apps Script projects into the dropdown.
         * @param {string} [selectedId=null] - The ID of the project to pre-select.
         */
        loadProjectsIntoDropdown: (selectedId = null) => {
            const scriptIdSelect = UI.get('scriptIdSelect');
            scriptIdSelect.innerHTML = '<option value="">-- Select a Script ID --</option>';

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.status === 'success') {
                        response.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.title;
                            scriptIdSelect.appendChild(option);
                        });
                        if (selectedId) {
                            scriptIdSelect.value = selectedId;
                            // Explicitly trigger change event to update editor URL display
                            scriptIdSelect.dispatchEvent(new Event('change'));
                        }
                    }
                    else {
                        alert('Failed to load Apps Script projects: ' + response.message);
                    }
                })
                .withFailureHandler(function(error) {
                    alert('Error loading Apps Script projects: ' + error.message);
                })
                .listAppsScriptProjects();
        },

        /**
         * Update the display for the Apps Script Editor URL.
         */
        updateEditorUrlDisplay: () => {
            const scriptId = Utils.getEffectiveScriptId();
            const editorUrlDisplayDiv = UI.get('editor-url-display');
            
            UI.setHtml('editor-url-display', '');

            if (!scriptId) {
                UI.setText('editor-url-display', 'Apps Script Editor URL: (Script ID needed)');
                return;
            }

            UI.setHtml('editor-url-display', 'Apps Script Editor URL: <span class="spinner" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle; margin: 0 5px;"></span> Loading...');

            Utils.saveScriptIdToLocalStorage(scriptId);

            const editorUrl = "https://script.google.com/d/" + scriptId + "/edit";
            UI.setHtml('editor-url-display', "Apps Script Editor URL: <a href=\"" + Utils.escapeHtml(editorUrl) + "\" target=\"_blank\">" + Utils.escapeHtml(editorUrl) + "</a>");
        },

        /**
         * Validate HTML syntax.
         * @param {string} htmlString - The HTML string to validate.
         * @param {string} fileName - The name of the file being validated.
         * @returns {{isValid: boolean, message?: string}} Validation result.
         */
        validateHtml: (htmlString, fileName) => {
            console.log(`HTML validation started for file: ${fileName}`);
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const parseError = doc.querySelector('parsererror');

            if (parseError) {
                const errorMessage = parseError.textContent;
                console.error(`HTML validation failed in ${fileName}:`, errorMessage);
                return { isValid: false, message: `Syntax error found in HTML file "${fileName}": ${errorMessage}` };
            }
            console.log(`HTML validation successful for file: ${fileName}`);
            return { isValid: true };
        },

        /**
         * Displays the file comparison and proposed changes in the UI.
         * @param {Array<object>} originalFiles - Array of original file objects.
         * @param {Array<object>} proposedFiles - Array of proposed file objects (with new source or replace operations).
         * @param {Array<string>} deletedFileNames - Array of file names marked for deletion.
         * @returns {boolean} True if any changes were displayed, false otherwise.
         */
        displayFileComparison: (originalFiles, proposedFiles, deletedFileNames) => {
            const proposedFilesDisplay = UI.get('proposed-files-display');
            proposedFilesDisplay.innerHTML = ''; // Clear previous content

            let hasChanges = false;

            // Create maps for easier lookup
            const originalFilesMap = new Map(originalFiles.map(f => [f.name, f]));
            const proposedFilesMap = new Map(proposedFiles.map(f => [f.name, f]));

            // 1. Display DELETED files
            deletedFileNames.forEach(deletedFileName => {
                const originalFile = originalFilesMap.get(deletedFileName);
                if (originalFile) { // Ensure the file actually existed in original project
                    hasChanges = true;
                    const ext = Utils.getFileExtension(originalFile.type);
                    // For deleted files, display original content as removed
                    const originalContentLines = Utils.getActualContentLines(originalFile.source);
                    const lineNumbersHtml = originalContentLines.map((_, i) => `<div>${i + 1}</div>`).join('');
                    const contentHtml = originalContentLines.map(line => `<div class="diff-line-removed">${Utils.escapeHtml(line) || '&nbsp;'}</div>`).join('');

                    const deletedHtml = `
                        <div class="file-comparison is-deleted">
                            <h4 class="title is-5">DELETED: <span class="file-name-deleted">${Utils.escapeHtml(deletedFileName)}.${ext}</span></h4>
                            <div class="deleted-message notification is-danger is-light">このファイルは削除が提案されています。元の内容は以下に示されています（取り消し線付き）：</div>
                            <pre><div class="line-numbers-col">${lineNumbersHtml}</div><div class="code-content-col">${contentHtml}</div></pre>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += deletedHtml;
                } else {
                    console.warn(`File '${deletedFileName}' was marked for deletion but not found in original files. Skipping deletion display.`);
                }
            });

            // 2. Display NEW, MODIFIED, or REPLACE files
            proposedFiles.forEach(proposedFile => {
                const originalFile = originalFilesMap.get(proposedFile.name);
                let fileContentHtml = '';

                if (proposedFile.type === 'REPLACE') {
                    // This is a REPLACE operation
                    hasChanges = true;
                    const originalSourceForReplace = originalFile ? originalFile.source : 'ファイルの内容は比較できません。';
                    const originalFileTypeForReplace = originalFile ? Utils.getFileExtension(originalFile.type) : 'unknown';

                    fileContentHtml = `
                        <div class="file-comparison is-replace">
                            <h4 class="title is-5">REPLACE Operation: ${Utils.escapeHtml(proposedFile.name)}.${originalFileTypeForReplace}</h4>
                            <p class="content">この操作はファイル内の特定のテキストを置換します。${proposedFile.isGlobalReplace ? 'すべての出現箇所が置換されます（グローバル置換）。' : '最初の出現箇所のみが置換されます。'}</p>
                            <div class="columns">
                                <div class="column">
                                    <h5 class="title is-6 has-text-danger">置換前テキスト:</h5>
                                    <pre class="replacement-view replacement-old">${Utils.escapeHtml(proposedFile.old_string)}</pre>
                                </div>
                                <div class="column">
                                    <h5 class="title is-6 has-text-success">置換後テキスト:</h5>
                                    <pre class="replacement-view replacement-new">${Utils.escapeHtml(proposedFile.new_string)}</pre>
                                </div>
                            </div>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += fileContentHtml;

                } else if (!originalFile) {
                    // This is a NEW file (exists in proposed but not in original)
                    hasChanges = true;
                    const ext = Utils.getFileExtension(proposedFile.type);
                    const proposedContentLines = Utils.getActualContentLines(proposedFile.source);
                    const lineNumbersHtml = proposedContentLines.map((_, i) => `<div>${i + 1}</div>`).join('');
                    const contentHtml = proposedContentLines.map(line => `<div class="diff-line-added">${Utils.escapeHtml(line) || '&nbsp;'}</div>`).join('');

                    fileContentHtml = `
                        <div class="file-comparison">
                            <h4 class="title is-5">NEW FILE: ${Utils.escapeHtml(proposedFile.name)}.${ext}</h4>
                            <div class="notification is-info is-light">これはAIによって提案された新しいファイルです。</div>
                            <pre><div class="line-numbers-col">${lineNumbersHtml}</div><div class="code-content-col">${contentHtml}</div></pre>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += fileContentHtml;

                } else if (originalFile.source !== proposedFile.source) {
                    // This is a MODIFIED file (exists in both, but source is different)
                    hasChanges = true;
                    const diffsHtml = Utils.generateFormattedDiffPanels(originalFile.source, proposedFile.source);
                    const ext = Utils.getFileExtension(proposedFile.type);
                    fileContentHtml = `
                        <div class="file-comparison">
                            <div class="original-file-panel">
                                <h4 class="title is-5">変更前: ${Utils.escapeHtml(originalFile.name)}.${ext}</h4>
                                <pre><div class="line-numbers-col">${diffsHtml.originalLineNumbersHtml}</div><div class="code-content-col">${diffsHtml.originalCodeContentHtml}</div></pre>
                            </div>
                            <div class="proposed-file-panel">
                                <h4 class="title is-5">変更後: ${Utils.escapeHtml(proposedFile.name)}.${ext}</h4>
                                <pre><div class="line-numbers-col">${diffsHtml.proposedLineNumbersHtml}</div><div class="code-content-col">${diffsHtml.proposedCodeContentHtml}</div></pre>
                            </div>
                        </div>
                    `;
                    proposedFilesDisplay.innerHTML += fileContentHtml;
                }
                // Files present in both original and proposed, but with identical content, are skipped (no display needed)
            });

            // If no changes at all (neither deleted, new, modified, nor replace operations)
            if (!hasChanges) {
                proposedFilesDisplay.innerHTML = `<p class="notification is-info is-light">選択されたスクリプトに対してAIからの変更提案はありません。これは、プロンプトがコード変更なしで完全に満たされたか、関連する変更が見つからなかったことを意味します。</p>`;
            }

            return hasChanges;
        },

        /**
         * Generate formatted diff panels HTML using diff_match_patch library,
         * ensuring character-level changes within a line are highlighted,
         * and each logical line is contained within its own <div>.
         * @param {string} originalSource - The original source code.
         * @param {string} proposedSource - The proposed source code.
         * @returns {{originalLineNumbersHtml: string, originalCodeContentHtml: string, proposedLineNumbersHtml: string, proposedCodeContentHtml: string}} HTML parts for diff display.
         */
        generateFormattedDiffPanels: (originalSource, proposedSource) => {
            const dmp = new diff_match_patch();
            let diffs = dmp.diff_main(originalSource, proposedSource);
            dmp.diff_cleanupSemantic(diffs); // Apply semantic cleanup for better diffs

            const originalLinesHtml = [];
            const proposedLinesHtml = [];
            const originalLineNumbers = [];
            const proposedLineNumbers = [];

            let currentOriginalLine = 1;
            let currentProposedLine = 1;

            // Buffers to accumulate parts of the current logical line (including inline HTML tags)
            let currentOriginalLineContent = [];
            let currentProposedLineContent = [];

            // Flags to determine overall line status
            let lineHadInsert = false;
            let lineHadDelete = false;

            for (let i = 0; i < diffs.length; ++i) {
                const type = diffs[i][0]; // DIFF_EQUAL, DIFF_INSERT, DIFF_DELETE
                const text = diffs[i][1];

                // Split the diff text segment by newline characters
                // An empty string in `textParts` means a blank line.
                const textParts = text.split('\n');

                for (let j = 0; j < textParts.length; ++j) {
                    const part = Utils.escapeHtml(textParts[j]); // Escape HTML for the segment part
                    const isLastPartInSegment = (j === textParts.length - 1);

                    // Append the HTML for this part to the current line buffers
                    if (type === DIFF_EQUAL) {
                        currentOriginalLineContent.push(part);
                        currentProposedLineContent.push(part);
                    } else if (type === DIFF_INSERT) {
                        currentOriginalLineContent.push(''); // Original side has nothing for an insertion
                        currentProposedLineContent.push(`<ins class="diff-char-added">${part}</ins>`);
                        lineHadInsert = true;
                    } else { // DIFF_DELETE
                        currentOriginalLineContent.push(`<del class="diff-char-removed">${part}</del>`);
                        currentProposedLineContent.push(''); // Proposed side has nothing for a deletion
                        lineHadDelete = true;
                    }

                    // If this is NOT the last part of the current diff text segment,
                    // it means a newline was encountered *within this diff segment*.
                    // This signals the end of a logical line for display.
                    if (!isLastPartInSegment) {
                        // Construct the full HTML for the current logical lines
                        const originalFullLine = currentOriginalLineContent.join('');
                        const proposedFullLine = currentProposedLineContent.join('');

                        // Determine the line status class based on the content accumulated for this logical line
                        let lineStatusClass = 'equal';
                        if (lineHadInsert && lineHadDelete) {
                            lineStatusClass = 'modified';
                        } else if (lineHadInsert) {
                            lineStatusClass = 'added';
                        } else if (lineHadDelete) {
                            lineStatusClass = 'removed';
                        }

                        // Push the completed line HTML and line numbers
                        originalLineNumbers.push(`<div>${currentOriginalLine}</div>`);
                        originalLinesHtml.push(`<div class="diff-line-${lineStatusClass}">${originalFullLine || '&nbsp;'}</div>`);

                        proposedLineNumbers.push(`<div>${currentProposedLine}</div>`);
                        proposedLinesHtml.push(`<div class="diff-line-${lineStatusClass}">${proposedFullLine || '&nbsp;'}</div>`);

                        // Increment line numbers for the next logical line
                        currentOriginalLine++;
                        currentProposedLine++;

                        // Reset buffers and flags for the next logical line
                        currentOriginalLineContent = [];
                        currentProposedLineContent = [];
                        lineHadInsert = false;
                        lineHadDelete = false;
                    }
                }
            }

            // After the loop, if there's any content left in buffers, it means the last logical line was processed.
            // Push this final line.
            if (currentOriginalLineContent.length > 0 || currentProposedLineContent.length > 0) {
                const originalFullLine = currentOriginalLineContent.join('');
                const proposedFullLine = currentProposedLineContent.join('');

                let lineStatusClass = 'equal';
                if (lineHadInsert && lineHadDelete) {
                    lineStatusClass = 'modified';
                } else if (lineHadInsert) {
                    lineStatusClass = 'added';
                } else if (lineHadDelete) {
                    lineStatusClass = 'removed';
                }

                originalLineNumbers.push(`<div>${currentOriginalLine}</div>`);
                originalLinesHtml.push(`<div class="diff-line-${lineStatusClass}">${originalFullLine || '&nbsp;'}</div>`);

                proposedLineNumbers.push(`<div>${currentProposedLine}</div>`);
                proposedLinesHtml.push(`<div class="diff-line-${lineStatusClass}">${proposedFullLine || '&nbsp;'}</div>`);
            }

            return {
                originalLineNumbersHtml: originalLineNumbers.join(''),
                originalCodeContentHtml: originalLinesHtml.join(''),
                proposedLineNumbersHtml: proposedLineNumbers.join(''),
                proposedCodeContentHtml: proposedLinesHtml.join('')
            };
        },

        /**
         * Splits a string into an array of lines, correctly handling trailing newlines.
         * A trailing newline character means the last line is empty and should be represented.
         * For example, "a\n" represents line "a" followed by an empty line.
         * @param {string} text - The input string.
         * @returns {Array<string>} An array of logical lines.
         */
        getActualContentLines: (text) => {
            if (text === null || text === undefined) {
                return [];
            }
            // text.split('\n') will correctly produce an empty string at the end
            // if the original text ends with '\n'. This empty string represents a valid, empty line.
            return text.split('\n');
        },

        /**
         * Helper to generate simple line numbers HTML for deleted/new files.
         * This function is now mostly for `DELETED` and `NEW` file types,
         * where `generateFormattedDiffPanels` is not used directly on the whole file.
         * @param {string} source - The source code.
         * @returns {string} HTML for line numbers.
         */
        generateLineNumbersHtml: (source) => {
            const lines = Utils.getActualContentLines(source);
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div>${i + 1}</div>`;
            }
            return html;
        },

        /**
         * Helper to generate simple source HTML for deleted/new files.
         * This function is now mostly for `DELETED` and `NEW` file types,
         * where `generateFormattedDiffPanels` is not used directly on the whole file.
         * @param {string} source - The source code.
         * @returns {string} HTML for source content.
         */
        generateSourceHtml: (source) => {
            const lines = Utils.getActualContentLines(source);
            let html = '';
            // For new/deleted files, all lines are essentially 'equal' within their own context for basic display,
            // but the `diff-line-removed` or `diff-line-added` class on the parent div provides context.
            for (let i = 0; i < lines.length; i++) {
                html += `<div class="diff-line-equal">${Utils.escapeHtml(lines[i]) || '&nbsp;'}</div>`; // Use equal as base, parent div takes care of add/remove styling
            }
            return html;
        },

        /**
         * Get file extension based on file type.
         * @param {string} type - The file type (SERVER_JS, JSON, HTML).
         * @returns {string} The corresponding file extension.
         */
        getFileExtension: (type) => {
            switch (type) {
                case 'SERVER_JS': return 'gs';
                case 'JSON': return 'json';
                default: return 'html';
            }
        },

        /**
         * Escape HTML entities in a string.
         * @param {string} text - The text to escape.
         * @returns {string} The escaped HTML string.
         */
        escapeHtml: (text) => {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }
    };
</script>