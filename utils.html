<script>
    // 3. Utility Functions
    const Utils = {
        /**
         * Get the effective Script ID (manual input takes precedence).
         * @returns {string} The effective Script ID.
         */
        getEffectiveScriptId: () => {
            return UI.get('scriptIdSelect').value.trim();
        },

        /**
         * Save the target Script ID to Local Storage.
         * @param {string} id - The Script ID to save.
         */
        saveScriptIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('targetScriptId', id);
            }
        },

        /**
         * Save the GCP Project ID to Local Storage.
         * @param {string} id - The GCP Project ID to save.
         */
        saveGcpProjectIdToLocalStorage: (id) => {
            if (id) {
                localStorage.setItem('gcpProjectId', id);
            }
        },

        /**
         * Load Apps Script projects into the dropdown.
         * @param {string} [selectedId=null] - The ID of the project to pre-select.
         */
        loadProjectsIntoDropdown: (selectedId = null) => {
            const scriptIdSelect = UI.get('scriptIdSelect');
            scriptIdSelect.innerHTML = '<option value="">-- Select a Script ID --</option>';

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.status === 'success') {
                        response.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.title;
                            scriptIdSelect.appendChild(option);
                        });
                        if (selectedId) {
                            scriptIdSelect.value = selectedId;
                            // Explicitly trigger change event to update editor URL display
                            scriptIdSelect.dispatchEvent(new Event('change'));
                        }
                    } else {
                        alert('Failed to load Apps Script projects: ' + response.message);
                    }
                })
                .withFailureHandler(function(error) {
                    alert('Error loading Apps Script projects: ' + error.message);
                })
                .listAppsScriptProjects();
        },

        /**
         * Update the display for the Apps Script Editor URL.
         */
        updateEditorUrlDisplay: () => {
            const scriptId = Utils.getEffectiveScriptId();
            const editorUrlDisplayDiv = UI.get('editor-url-display');
            
            UI.setHtml('editor-url-display', '');

            if (!scriptId) {
                UI.setText('editor-url-display', 'Apps Script Editor URL: (Script ID needed)');
                return;
            }

            UI.setHtml('editor-url-display', 'Apps Script Editor URL: <span class="spinner" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle; margin: 0 5px;"></span> Loading...');

            Utils.saveScriptIdToLocalStorage(scriptId);

            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.startsWith("Error:")) {
                        UI.setText('editor-url-display', `Apps Script Editor URL: ${response}`);
                    } else {
                        UI.setHtml('editor-url-display', `Apps Script Editor URL: <a href="${response}" target="_blank">${response}</a>`);
                    }
                })
                .withFailureHandler(function(error) {
                    UI.setText('editor-url-display', `Apps Script Editor URL: Error - ${error.message}`);
                })
                .getScriptEditorUrl(scriptId);
        },

        /**
         * Validate HTML syntax.
         * @param {string} htmlString - The HTML string to validate.
         * @param {string} fileName - The name of the file being validated.
         * @returns {{isValid: boolean, message?: string}} Validation result.
         */
        validateHtml: (htmlString, fileName) => {
            console.log(`HTML validation started for file: ${fileName}`);
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const parseError = doc.querySelector('parsererror');

            if (parseError) {
                const errorMessage = parseError.textContent;
                console.error(`HTML validation failed in ${fileName}:`, errorMessage);
                return { isValid: false, message: `Syntax error found in HTML file "${fileName}": ${errorMessage}` };
            }
            console.log(`HTML validation successful for file: ${fileName}`);
            return { isValid: true };
        },

        /**
         * Generate formatted diff panels HTML.
         * @param {string} originalSource - The original source code.
         * @param {string} proposedSource - The proposed source code.
         * @returns {{originalLineNumbersHtml: string, originalCodeContentHtml: string, proposedLineNumbersHtml: string, proposedCodeContentHtml: string}} HTML parts for diff display.
         */
        generateFormattedDiffPanels: (originalSource, proposedSource) => {
            const originalLines = originalSource ? originalSource.split('\n') : [];
            const proposedLines = proposedSource ? proposedSource.split('\n') : [];

            const diffResult = [];
            let i = 0;
            let j = 0;
            const lookAheadWindow = 5;

            while (i < originalLines.length || j < proposedLines.length) {
                const currentOriginalLine = originalLines[i];
                const currentProposedLine = proposedLines[j];

                if (i < originalLines.length && j < proposedLines.length && currentOriginalLine === currentProposedLine) {
                    diffResult.push({ type: 'equal', original: currentOriginalLine, proposed: currentProposedLine });
                    i++;
                    j++;
                } else {
                    let originalFoundInProposedAhead = -1;
                    for (let k = j + 1; k < Math.min(j + 1 + lookAheadWindow, proposedLines.length); k++) {
                        if (i < originalLines.length && originalLines[i] === proposedLines[k]) {
                            originalFoundInProposedAhead = k;
                            break;
                        }
                    }

                    let proposedFoundInOriginalAhead = -1;
                    for (let k = i + 1; k < Math.min(i + 1 + lookAheadWindow, originalLines.length); k++) {
                        if (j < proposedLines.length && proposedLines[j] === originalLines[k]) {
                            proposedFoundInOriginalAhead = k;
                            break;
                        }
                    }

                    if (i < originalLines.length && j < proposedLines.length && originalFoundInProposedAhead === -1 && proposedFoundInOriginalAhead === -1) {
                        diffResult.push({ type: 'modified', original: currentOriginalLine, proposed: currentProposedLine });
                        i++;
                        j++;
                    } else if (originalFoundInProposedAhead !== -1 && (proposedFoundInOriginalAhead === -1 || (originalFoundInProposedAhead - j) <= (proposedFoundInOriginalAhead - i))) {
                        diffResult.push({ type: 'added', original: '', proposed: currentProposedLine });
                        j++;
                    } else if (proposedFoundInOriginalAhead !== -1 && (originalFoundInProposedAhead === -1 || (proposedFoundInOriginalAhead - j) < (proposedFoundInOriginalAhead - i))) {
                        diffResult.push({ type: 'removed', original: currentOriginalLine, proposed: '' });
                        i++;
                    } else if (i < originalLines.length) {
                        diffResult.push({ type: 'removed', original: currentOriginalLine, proposed: '' });
                        i++;
                    } else if (j < proposedLines.length) {
                        diffResult.push({ type: 'added', original: '', proposed: currentProposedLine });
                        j++;
                    }
                }
            }

            const OMIT_THRESHOLD = 8;
            const CONTEXT_LINES = 3;

            let originalLineNumbersHtml = '';
            let originalCodeContentHtml = '';
            let proposedLineNumbersHtml = '';
            let proposedCodeContentHtml = '';

            let currentOriginalLineNum = 1;
            let currentProposedLineNum = 1;

            let k = 0;
            while (k < diffResult.length) {
                const entry = diffResult[k];

                if (entry.type === 'equal') {
                    let equalBlockStartIndex = k;
                    let equalCount = 0;

                    while (k < diffResult.length && diffResult[k].type === 'equal') {
                        equalCount++;
                        k++;
                    }

                    if (equalCount > OMIT_THRESHOLD) {
                        for (let l = 0; l < CONTEXT_LINES; l++) {
                            const lineEntry = diffResult[equalBlockStartIndex + l];
                            originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                            originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.original)}</div>`;
                            proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                            proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.proposed)}</div>`;
                            currentOriginalLineNum++;
                            currentProposedLineNum++;
                        }

                        const omittedLinesCount = equalCount - (2 * CONTEXT_LINES);
                        const originalOmittedStart = currentOriginalLineNum;
                        const proposedOmittedStart = currentProposedLineNum;

                        currentOriginalLineNum += omittedLinesCount;
                        currentProposedLineNum += omittedLinesCount;

                        originalLineNumbersHtml += `<div class="diff-line-omitted">${originalOmittedStart}-${currentOriginalLineNum - 1}</div>`;
                        originalCodeContentHtml += `<div class="diff-line-omitted">... ${omittedLinesCount} lines omitted ...</div>`;
                        proposedLineNumbersHtml += `<div class="diff-line-omitted">${proposedOmittedStart}-${currentProposedLineNum - 1}</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-omitted">... ${omittedLinesCount} lines omitted ...</div>`;

                        for (let l = 0; l < CONTEXT_LINES; l++) {
                            const lineEntry = diffResult[equalBlockStartIndex + equalCount - CONTEXT_LINES + l];
                            originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                            originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.original)}</div>`;
                            proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                            proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.proposed)}</div>`;
                            currentOriginalLineNum++;
                            currentProposedLineNum++;
                        }

                    } else {
                        for (let l = 0; l < equalCount; l++) {
                            const lineEntry = diffResult[equalBlockStartIndex + l];
                            originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                            originalCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.original)}</div>`;
                            proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                            proposedCodeContentHtml += `<div class="diff-line-equal">${Utils.escapeHtml(lineEntry.proposed)}</div>`;
                            currentOriginalLineNum++;
                            currentProposedLineNum++;
                        }
                    }
                } else {
                    if (entry.type === 'added') {
                        originalLineNumbersHtml += `<div>&nbsp;</div>`;
                        originalCodeContentHtml += `<div class="diff-line-empty-fill">&nbsp;</div>`;
                        proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-added">${Utils.escapeHtml(entry.proposed)}</div>`;
                        currentProposedLineNum++;
                    } else if (entry.type === 'removed') {
                        originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                        originalCodeContentHtml += `<div class="diff-line-removed">${Utils.escapeHtml(entry.original)}</div>`;
                        proposedLineNumbersHtml += `<div>&nbsp;</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-empty-fill">&nbsp;</div>`;
                        currentOriginalLineNum++;
                    } else if (entry.type === 'modified') {
                        originalLineNumbersHtml += `<div>${currentOriginalLineNum}</div>`;
                        originalCodeContentHtml += `<div class="diff-line-modified">${Utils.escapeHtml(entry.original)}</div>`;
                        proposedLineNumbersHtml += `<div>${currentProposedLineNum}</div>`;
                        proposedCodeContentHtml += `<div class="diff-line-modified">${Utils.escapeHtml(entry.proposed)}</div>`;
                        currentOriginalLineNum++;
                        currentProposedLineNum++;
                    }
                    k++;
                }
            }

            return {
                originalLineNumbersHtml, originalCodeContentHtml,
                proposedLineNumbersHtml, proposedCodeContentHtml
            };
        },

        /**
         * Display file comparisons in the UI.
         * @param {Array<object>} originalFiles - The original files array.
         * @param {Array<object>} proposedFiles - The proposed files array.
         * @param {Array<string>} [deletedFileNames=[]] - Array of file names explicitly marked for deletion by AI.
         */
        displayFileComparison: (originalFiles, proposedFiles, deletedFileNames = []) => {
            const displayArea = UI.get('proposedFilesDisplay');
            UI.setHtml('proposedFilesDisplay', '');

            const originalFilesMap = new Map(originalFiles.map(f => [f.name, f]));
            const finalProposedFilesForDisplay = new Map(); // Will store processed SOURCE type files for display
            const replaceOperationsGrouped = new Map(); // Will store arrays of REPLACE ops per file

            // First pass: Separate SOURCE and REPLACE operations
            proposedFiles.forEach(propFile => {
                if (propFile.type === 'REPLACE') {
                    if (!replaceOperationsGrouped.has(propFile.name)) {
                        replaceOperationsGrouped.set(propFile.name, []);
                    }
                    replaceOperationsGrouped.get(propFile.name).push(propFile);
                } else {
                    // Directly add SOURCE type files (new or full updates)
                    finalProposedFilesForDisplay.set(propFile.name, propFile);
                }
            });

            // Second pass: Apply REPLACE operations and consolidate
            replaceOperationsGrouped.forEach((replaceOps, fileName) => {
                const originalFile = originalFilesMap.get(fileName);
                if (!originalFile) {
                    console.warn(`Skipping REPLACE operations for file '${fileName}': original file not found.`);
                    return;
                }

                let currentSource = originalFile.source;
                let replacementPerformed = false; // Track if any replacement actually modified the source

                replaceOps.forEach(op => {
                    if (typeof op.old_string !== 'string' || typeof op.new_string !== 'string') {
                        console.warn(`REPLACE operation for '${op.name}' has malformed old_string or new_string. Skipping.`);
                        return;
                    }
                    if (op.isGlobalReplace === true) {
                        if (currentSource.includes(op.old_string)) {
                            currentSource = currentSource.replaceAll(op.old_string, op.new_string);
                            replacementPerformed = true;
                        }
                    } else {
                        if (currentSource.includes(op.old_string)) {
                            currentSource = currentSource.replace(op.old_string, op.new_string);
                            replacementPerformed = true;
                        }
                    }
                });

                // Only add to finalProposedFilesForDisplay if actual changes occurred or if the REPLACE ops were meant for an existing file
                // and it wasn't already fully updated by a 'source' type proposal. Priority given to REPLACE if both exist.
                if (replacementPerformed || currentSource !== originalFile.source || replaceOps.length > 0) { // Add || replaceOps.length > 0 to ensure if no change occurred but ops were proposed, it's still shown
                    finalProposedFilesForDisplay.set(fileName, {
                        name: fileName,
                        type: originalFile.type,
                        source: currentSource,
                        isConsolidatedReplace: true,
                        originalReplaceOps: replaceOps
                    });
                } else {
                    console.log(`No actual changes from REPLACE operations for file '${fileName}'. Not adding to proposed files for display.`);
                }
            });

            // Filter out deleted files from the finalProposedFilesForDisplay map
            deletedFileNames.forEach(deletedName => {
                finalProposedFilesForDisplay.delete(deletedName);
            });

            const filesToDisplay = Array.from(finalProposedFilesForDisplay.values());
            filesToDisplay.sort((a, b) => a.name.localeCompare(b.name)); // Sort for consistent display

            if (deletedFileNames.length === 0 && filesToDisplay.length === 0) {
                UI.setHtml('proposedFilesDisplay', '<p>AI did not propose any changes (no files added, updated, or deleted).</p>');
                return;
            }

            explicitDeletedFiles.forEach(deletedFile => {
                const name = deletedFile.name;
                const fileType = deletedFile.type;
                const originalSource = deletedFile.source;

                const fileComparisonDiv = document.createElement('div');
                fileComparisonDiv.className = 'file-comparison is-deleted';

                fileComparisonDiv.innerHTML = `
                    <div>
                        <h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Original)</h4>
                        <pre class="scroll-sync-target">
                            <div class="line-numbers-col">
                                ${Utils.generateLineNumbersHtml(originalSource)}
                            </div>
                            <div class="code-content-col">
                                ${Utils.generateSourceHtml(originalSource)}
                            </div>
                        </pre>
                    </div>
                    <div>
                        <h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Proposed) <span class="file-name-deleted">(DELETED)</span></h4>
                        <div class="deleted-message">
                            <p>このファイルは削除されます。</p>
                            <p>元のコンテンツは参照用に左側に表示されています。</p>
                        </div>
                    </div>
                `;
                displayArea.appendChild(fileComparisonDiv);
            });

            filesToDisplay.forEach(proposedFile => {
                const name = proposedFile.name;
                const fileType = proposedFile.type;
                
                const fileComparisonDiv = document.createElement('div');
                fileComparisonDiv.className = 'file-comparison';

                const originalFile = originalFilesMap.get(name);
                const originalSourceForDiff = originalFile ? originalFile.source : '';
                const proposedSourceForDiff = proposedFile.source;
                let statusLabel;
                let additionalMessageHtml = '';

                if (proposedFile.isConsolidatedReplace) {
                    statusLabel = '(複数回の置換適用済み)'; // More descriptive label
                    fileComparisonDiv.classList.add('is-replace'); // Keep the styling class
                    
                    // Generate a summary of the replace operations for the message
                    const replaceOpsSummary = proposedFile.originalReplaceOps.map((op, index) => {
                        const opType = op.isGlobalReplace ? '全ての出現箇所を置換' : '最初の出現箇所を置換';
                        const oldStringSnippet = Utils.escapeHtml(op.old_string.substring(0, 100)) + (op.old_string.length > 100 ? '...' : '');
                        const newStringSnippet = Utils.escapeHtml(op.new_string.substring(0, 100)) + (op.new_string.length > 100 ? '...' : '');
                        return `
                            <li>
                                <strong>置換 #${index + 1} (${opType}):</strong><br>
                                &nbsp;&nbsp;元文字列: <pre class="replacement-view replacement-old">${oldStringSnippet}</pre><br>
                                &nbsp;&nbsp;新文字列: <pre class="replacement-view replacement-new">${newStringSnippet}</pre>
                            </li>
                        `;
                    }).join('');

                    additionalMessageHtml = `
                        <div class="notification is-info is-light mt-2 mb-2" style="flex: 1 1 100%;">
                            <p>この差分表示は、提案された複数回の置換操作をこのファイルに統合適用した結果を示しています。</p>
                            <p class="mt-2 is-size-7">適用された置換操作の概要:</p>
                            <ul class="is-size-7" style="list-style: none; margin-left: 0; padding-left: 10px;">${replaceOpsSummary}</ul>
                        </div>
                    `;
                } else {
                    statusLabel = originalFile ? '(Updated)' : '(New File)';
                }

                const diffHtmlData = Utils.generateFormattedDiffPanels(originalSourceForDiff, proposedSourceForDiff);

                const originalContentDiv = document.createElement('div');
                originalContentDiv.innerHTML = `<h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Original)</h4><pre class="scroll-sync-target">
                    <div class="line-numbers-col">${diffHtmlData.originalLineNumbersHtml}</div>
                    <div class="code-content-col">${diffHtmlData.originalCodeContentHtml}</div>
                </pre>`;
                
                const proposedContentDiv = document.createElement('div');
                proposedContentDiv.innerHTML = `<h4>${Utils.escapeHtml(name)}.${Utils.getFileExtension(fileType)} (Proposed) <span class="has-text-info is-size-7">${statusLabel}</span></h4><pre class="scroll-sync-target">
                    <div class="line-numbers-col">${diffHtmlData.proposedLineNumbersHtml}</div>
                    <div class="code-content-col">${diffHtmlData.proposedCodeContentHtml}</div>
                </pre>`;
                
                fileComparisonDiv.appendChild(originalContentDiv);
                fileComparisonDiv.appendChild(proposedContentDiv);
                
                if (additionalMessageHtml) {
                    const messageContainer = document.createElement('div');
                    messageContainer.style.flex = '1 1 100%';
                    messageContainer.innerHTML = additionalMessageHtml;
                    fileComparisonDiv.appendChild(messageContainer);
                }

                displayArea.appendChild(fileComparisonDiv);

                const preElements = fileComparisonDiv.querySelectorAll('.scroll-sync-target');
                if (preElements.length === 2) {
                    const pre1 = preElements[0];
                    const pre2 = preElements[1];

                    let isSyncing = false;
                    pre1.addEventListener('scroll', function() {
                        if (!isSyncing) { isSyncing = true; pre2.scrollTop = pre1.scrollTop; isSyncing = false; }
                    });
                    pre2.addEventListener('scroll', function() {
                        if (!isSyncing) { isSyncing = true; pre1.scrollTop = pre2.scrollTop; isSyncing = false; }
                    });
                }
            });
        },

        /**
         * Helper to generate simple line numbers HTML for deleted files.
         * @param {string} source - The source code.
         * @returns {string} HTML for line numbers.
         */
        generateLineNumbersHtml: (source) => {
            const lines = source ? source.split('\n') : [];
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div>${i + 1}</div>`;
            }
            return html;
        },

        /**
         * Helper to generate simple source HTML for deleted files.
         * @param {string} source - The source code.
         * @returns {string} HTML for source content.
         */
        generateSourceHtml: (source) => {
            const lines = source ? source.split('\n') : [];
            let html = '';
            for (let i = 0; i < lines.length; i++) {
                html += `<div class="diff-line-equal">${Utils.escapeHtml(lines[i])}</div>`;
            }
            return html;
        },

        /**
         * Get file extension based on file type.
         * @param {string} type - The file type (SERVER_JS, JSON, HTML).
         * @returns {string} The corresponding file extension.
         */
        getFileExtension: (type) => {
            switch (type) {
                case 'SERVER_JS': return 'gs';
                case 'JSON': return 'json';
                default: return 'html';
            }
        },

        /**
         * Escape HTML entities in a string.
         * @param {string} text - The text to escape.
         * @returns {string} The escaped HTML string.
         */
        escapeHtml: (text) => {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }
    };
</script>